\documentclass{scrartcl}

\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{ragged2e}
\usepackage{hyperref}

\DeclareMathOperator{\apply}{apply}
\DeclareMathOperator{\ifop}{if}
\DeclareMathOperator{\thenop}{then}
\DeclareMathOperator{\elseop}{else}
\DeclareMathOperator{\checkop}{check}
\DeclareMathOperator{\fby}{fby}
\DeclareMathOperator{\where}{where}
\DeclareMathOperator{\choke}{choke}
\DeclareMathOperator{\foreach}{\mathbf{foreach}}

\DeclareMathOperator{\ite}{ite}
\DeclareMathOperator{\num}{num}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\bool}{bool}

\DeclareMathOperator{\compat}{\mathbf{compat}}

\DeclareMathOperator{\gtypes}{\Delta}

\makeindex

\begin{document}
    \title{Pixy formal semantics}
    \author{A. Finn Hackett, Reed Mullanix}
    \maketitle
    
    Basic context:
    \begin{enumerate}
        \item $\Gamma$ is the typing context
        \item $S$ is the state at $t-1$
        \item $t$ is the current timestep
        \item $\Rightarrow$ is normal type synthesis
        \item $\overset{C}{\Rightarrow}$ is "choked" type synthesis, for use as per my last "if" spec. Watch what where does under those circumstances.
        \item $\Downarrow$ is evaluation, not explicitly defined but used in ite
        \item $\fby$ also uses a choke-based strategy, which should help formalise the idea of "stopping the lhs" and what exactly happens to rhs when we're still
        waiting for lhs. No buffers!
        \item A naive implementation should be terrible but work. I have ideas on how to optimise later. The key to not going forever is to realise that the result will always be the same for the same S, and memoising our way to a stop.
        \item $\compat$ is to ensure that types remain consistent over time - it keeps a global map and ensures that for any time $t$ a variable has type $1$ or the same type $T$.
        \item $\gtypes$ is the global map mentioned above
    \end{enumerate}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \gtypes_0; \Gamma; S; t \vdash C \Rightarrow Boolean; \gtypes_1 \\
        \Gamma; S; t \vdash C \Downarrow true \\
        \gtypes_1; \Gamma; S; t \vdash A \Rightarrow T; \gtypes_2 \\
        \gtypes_2; \Gamma; S; t \vdash B \overset{C}{\Leftarrow} 1; \gtypes_3
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \ite(C,A,B) \Rightarrow T; \gtypes_3
    }[\mathtt{Synth-ite-true}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \gtypes_0; \Gamma; S; t \vdash C \Rightarrow Boolean; \gtypes_1 \\
        \Gamma; S; t \vdash C \Downarrow false;  \\
        \gtypes_1; \Gamma; S; t \vdash A \overset{C}{\Leftarrow} 1; \gtypes_2 \\
        \gtypes_2; \Gamma; S; t \vdash B \Rightarrow T; \gtypes_2
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \ite(C,A,B) \Rightarrow T; \gtypes_3
    }[\mathtt{Synth-ite-false}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \gtypes_0; \Gamma; S; t \vdash C \Rightarrow 1; \gtypes_1 \\
        \gtypes_1; \Gamma; S; t \vdash A \overset{C}{\Leftarrow} 1; \gtypes_2 \\
        \gtypes_2; \Gamma; S; t \vdash B \overset{C}{\Leftarrow} 1; \gtypes_3
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \ite(C,A,B) \Rightarrow 1; \gtypes_3
    }[\mathtt{Synth-ite-nil}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \gtypes_0; \Gamma; S; t \vdash C \overset{C}{\Rightarrow} 1; \gtypes_1 \\
        \gtypes_1; \Gamma; S; t \vdash A \overset{C}{\Rightarrow} 1; \gtypes_2 \\
        \gtypes_2; \Gamma; S; t \vdash B \overset{C}{\Rightarrow} 1; \gtypes_3
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \ite(C,A,B) \overset{C}{\Rightarrow} 1; \gtypes_3
    }[\mathtt{Synth-ite-C}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        S(L) = 0 \\
        \gtypes_0; \Gamma; S; t \vdash B \overset{C}{\Rightarrow} 1; \gtypes_1 \\
        \gtypes_1; \Gamma; S; t \vdash A \Rightarrow T; \gtypes_2
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \fby(A, B, L) \Rightarrow T; \gtypes_2
    }[\mathtt{Synth-fby-before}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        S(L) = 1 \\
        \gtypes_0; \Gamma; S; t \vdash A \overset{C}{\Rightarrow} 1; \gtypes_1 \\
        \gtypes_1; \Gamma; S; t \vdash B \Rightarrow T; \gtypes_2
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \fby(A, B, L) \Rightarrow T; \gtypes_2
    }[\mathtt{Synth-fby-after}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        S(L) = 0 \\
        \gtypes_0; \Gamma; S; t \vdash B \overset{C}{\Rightarrow} 1; \gtypes_1 \\
        \gtypes_1; \Gamma; S; t \vdash A \overset{C}{\Rightarrow} T; \gtypes_2
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \fby(A, B, L) \overset{C}{\Rightarrow} T; \gtypes_2
    }[\mathtt{Synth-fby-before-C}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        S[t](L) = 1 \\
        \gtypes_0; \Gamma; S; t \vdash A \overset{C}{\Rightarrow} 1; \gtypes_1 \\
        \gtypes_1; \Gamma; S; t \vdash B \overset{C}{\Rightarrow} T; \gtypes_2
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \fby(A, B, L) \overset{C}{\Rightarrow} T; \gtypes_2
    }[\mathtt{Synth-fby-after-C}]
    \end{align*}
    
    \begin{align*}
    \frac{}{
        \gtypes \vdash L \compat nil; \gtypes
    }[\mathtt{Compat-nil}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \gtypes(L) = T, T \neq nil
    }{
        \gtypes \vdash L \compat T; \gtypes
    }[\mathtt{Compat-found}]
    \end{align*}
    
    \begin{align*}
    \frac{
        L \notin \gtypes, T \neq nil
    }{
        \gtypes \vdash L \compat T; L : T, \gtypes
    }[\mathtt{Compat-learn}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \overline{\emptyset; \emptyset; S; t \vdash S(l) \Rightarrow T_l; \_}^{l : c \in C} \\
        \overline{\gtypes_{i-1}; \overline{l' : T_{l'}}^{l' : c' \in C}, \Gamma; S; t \vdash c \Rightarrow T'_l; \gtypes_{i}}^{l : c \in C, i \in 1 .. |C|} \\
        \overline{\gtypes_{|C|+i-1} \vdash l \compat T'_l; \gtypes_{|C|+i}}^{l : c \in C, i \in 1 .. |C|} \\
        \gtypes_{2|C|}; \overline{l : T_l}^{l : c \in C}, \Gamma; S; t \vdash V \Rightarrow T; \gtypes_{2|C|+1}
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \where(V, C) \Rightarrow T; \gtypes_{2|C|+1}
    }[\mathtt{Synth-where}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \overline{\emptyset; \emptyset; S; t \vdash S(l) \Rightarrow T_l; \_}^{l : c \in C} \\
        \overline{\gtypes_{i-1}; \overline{l_2 : T_{l_2}}^{l_2 : c_2 \in C}, \overline{l_3 : 1}^{l_3 : t_3 \in \Gamma}; S; t \vdash c_1 \Rightarrow T'_{l_1}; \gtypes_i}^{l_1: c_1 \in C, i \in |C|} \\
        \overline{\gtypes_{|C|+i-1} \vdash l \compat T'_l; \gtypes_{|C|+i}}^{l : c \in C, i \in 1 .. |C|} \\
        \gtypes_{2|C|}; \overline{l : T_l}^{l: c \in C}, \overline{l : 1}^{l : t \in \Gamma}; S; t \vdash V \overset{C}{\Rightarrow} T; \gtypes_{2|C|+1}
        \end{matrix}
    }{
        \gtypes_0; \Gamma; S; t \vdash \where(V, C) \overset{C}{\Rightarrow} T; \gtypes_{2|C|+1}
    }[\mathtt{Synth-where-C}]
    \end{align*}
    
    \begin{align*}
    \frac{}{
        \gtypes; \Gamma; S; t \vdash nil \Rightarrow 1; \gtypes
    }[\mathtt{Synth-nil}]
    \end{align*}
    
    \begin{align*}
    \frac{}{
        \gtypes; \Gamma; S; t \vdash nil \overset{C}{\Rightarrow} 1; \gtypes
    }[\mathtt{Synth-nil-C}]
    \end{align*}
    
    \begin{align*}
    \frac{}{
        \gtypes; \Gamma; S; t \vdash \num(N) \Rightarrow Number; \gtypes
    }[\mathtt{Synth-num}]
    \end{align*}
    
    \begin{align*}
    \frac{}{
        \gtypes; \Gamma; S; t \vdash \num(N) \overset{C}{\Rightarrow} 1; \gtypes
    }[\mathtt{Synth-num-C}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \Gamma(I) = T
    }{
        \gtypes; \Gamma; S; t \vdash \id(I) \Rightarrow T; \gtypes
    }[\mathtt{Synth-id}]
    \end{align*}
    
    \begin{align*}
    \frac{
        \Gamma(I) = T
    }{
        \gtypes; \Gamma; S; t \vdash \id(I) \overset{C}{\Rightarrow} 1; \gtypes
    }[\mathtt{Synth-id-C}]
    \end{align*}
    
    \begin{align*}
    \frac{}{
        \gtypes; \Gamma; S; t \vdash \bool(B) \Rightarrow Boolean; \gtypes
    }[\mathtt{Synth-boolean}]
    \end{align*}
    
    \begin{align*}
    \frac{}{
        \gtypes; \Gamma; S; t \vdash \bool(B) \overset{C}{\Rightarrow} 1; \gtypes
    }[\mathtt{Synth-boolean-C}]
    \end{align*}
    
    \section{Introduction}
    
    The evaluation rules of Pixy are split into two steps: construction and evaluation.
    
    First, any preprocessing is performed such as determining and allocating queue sizes or scanning for free variables.
    
    Then the evaluation rules are applied to the result of this step in order to execute the progam.
    
    \section{Utilities}
    
    \begin{align*}
        \apply(E, nil) & = \exists v \in freevariables(E), \apply(E[v/nil], nil) \\
        \apply(E, <>) & = E \\
        \apply(E, <<n, v>, R...>) & = \apply(E[n/v], R)
    \end{align*}
    
    \section{If}
    
    If has some quite interesting semantics - unlike in many languages it does not completely skip
    the evaluation of the subexpression it does not select. Instead, it always executes both
    subexpressions except that when a subexpression is not selected the inputs are replaced
    by nil. This has the effect of synchronising time between both branches regardless of which
    if chosen, while avoiding the catastrophically bad performance of actually providing data
    for both branches to process.
    
    \subsection{Evaluation}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \Gamma_1 \vdash C \Rightarrow \Gamma_2 \vdash nil \\
        \Gamma_2 \vdash \choke(T) \Rightarrow \Gamma_3 \vdash nil \\
        \Gamma_3 \vdash \choke(F) \Rightarrow \Gamma_4 \vdash nil
        \end{matrix}
    }{
        \Gamma \vdash \ifop(C, T, F) \Rightarrow \Gamma_4 \vdash nil
    }\mathtt{Eval-if-nil}
    \end{align*}
    \begin{align*}
    \frac{
        \begin{matrix}
        \Gamma_1 \vdash C \Rightarrow \Gamma_2 \vdash true \\
        \Gamma_2 \vdash T \Rightarrow \Gamma_3 \vdash V \\
        \Gamma_3 \vdash \choke(F) \Rightarrow \Gamma_4 \vdash nil
        \end{matrix}
    }{
        \Gamma \vdash \ifop(C, T, F) \Rightarrow \Gamma_4 \vdash V
    }\mathtt{Eval-if-true}
    \end{align*}
    \begin{align*}
    \frac{
        \begin{matrix}
        \Gamma_1 \vdash C \Rightarrow \Gamma_2 \vdash false \\
        \Gamma_2 \vdash \choke(T) \Rightarrow \Gamma_3 \vdash nil \\
        \Gamma_3 \vdash F \Rightarrow \Gamma_4 \vdash V
        \end{matrix}
    }{
        \Gamma \vdash \ifop(C, T, F) \Rightarrow \Gamma_4 \vdash V
    }\mathtt{Eval-if-false}
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \Gamma_1 \vdash \choke(C) \Rightarrow \Gamma_2 \vdash nil \\
        \Gamma_2 \vdash \choke(T) \Rightarrow \Gamma_3 \vdash nil \\
        \Gamma_3 \vdash \choke(F) \Rightarrow \Gamma_4 \vdash nil
        \end{matrix}
    }{
        \Gamma \vdash \ifop(C, T, F) \Rightarrow \Gamma_4 \vdash nil
    }\mathtt{Choke-if}
    \end{align*}
    
    \subsection{Construction}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \Gamma |- S | C => \Gamma |- S_1 | C_{e} \\
        \Gamma |- S_1 | Tsrc => \Gamma |- S_2 | T_{e} \\
        \Gamma |- S_2 | Fsrc => \Gamma |- S_3 | F_{e}
        \end{matrix}
    }
    {\Gamma |- S \left| \begin{matrix}
        \ifop C \thenop T \\
        \elseop F
        \end{matrix} \right. =>
        \begin{matrix}
        \ifop(C_{expr}, <T_{expr}, T_{vars}>, <F_{expr}, F_{vars}>), \\
        C_{vars} \cup T_{vars} \cup F_{vars}
        \end{matrix}
    }\mathtt{Construct-if}
    \end{align*}
    
    \section{fby}
    
    \subsection{Evaluation}
    
    \begin{align*}
    \frac{
        S => false, L => nil, R => nil
    }{
        \fby(L, R, S, Q) => nil
    }\mathtt{Eval-fby-1}
    \end{align*}
    \begin{align*}
    \frac{
        S => false, L => nil, R => R_{val}, R_{val} \neq nil, push(Q, R_{val})
    }{
        \fby(L, R, S, Q) => nil
    }\mathtt{Eval-fby-2}
    \end{align*}
    \begin{align*}
    \frac{
        S => false, L => L_{val}, L_{val} \neq nil, R => R_{val}, R_{val} \neq nil, push(Q, R_{val}), set(S, true)
    }{
        \fby(L, R, S, Q) => L_{val}
    }\mathtt{Eval-fby-3}
    \end{align*}
    \begin{align*}
    \frac{
        S => true, R => R_{val}, R_{val} \neq nil, \lnot empty(Q), push(Q, R_{val})
    }{
        \fby(L, R, S, Q) => pop(Q)
    }\mathtt{Eval-fby-4}
    \end{align*}
    \begin{align*}
    \frac{
        S => true, R => R_{val}, R_{val} \neq nil, empty(Q)
    }{
        \fby(L, R, S, Q) => R_{val}
    }\mathtt{Eval-fby-5}
    \end{align*}
    \begin{align*}
    \frac{
        S => true, R => nil, empty(Q)
    }{
        \fby(L, R, S, Q) => nil
    }\mathtt{Eval-fby-6}
    \end{align*}
    \begin{align*}
    \frac{
        S => true, R => nil, \lnot empty(Q)
    }{
        \fby(L, R, S, Q) => pop(Q)
    }\mathtt{Eval-fby-7}
    \end{align*}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \Gamma \vdash \choke(L) \Rightarrow \Gamma_1 \vdash nil \\
        \Gamma_1 \vdash \choke(R) \Rightarrow \Gamma_2 \vdash nil
        \end{matrix}
    }{
        \Gamma \vdash \fby(L, R, S, Q) \Rightarrow \Gamma_2 \vdash nil
    }\mathtt{Choke-fby}
    \end{align*}
    
    \subsection{Construction}
    
    \begin{align*}
    \frac{
        \begin{matrix}
        \Gamma |- S | L => \Gamma |- S_1 | L_{expr}, L_{vars} \\
        \Gamma |- S_1 | R => \Gamma |- S_2 | R_{expr}, R_{vars} \\
        d = maxdistance(L_{expr}, R_{expr}) \\
        <Q_f, \Gamma'> = fresh(Q, \Gamma) \\
        <P_f, \Gamma''> = fresh(P, \Gamma') \\
        S_3 = alloc(d, Q_f, S_2) \\
        S_4 = alloc(P_f, S_3) \\
        \end{matrix}
    }{
        \Gamma |- S | L \fby R => \Gamma'' |- S_4 | \fby(L_{expr}, R_{expr}, P_f, Q_f), L_{vars} \cup R_{vars}
    }\mathtt{Construct-fby}
    \end{align*}
    
    \section{check}
    
    \subsection{Evaluation}
    
    \begin{align*}
        \frac{
            E => nil
        }{
            \checkop(E) => false
        }\mathtt{Eval-check-nil}
    \end{align*}
    \begin{align*}
        \frac{
            E => v, v \neq nil
        }{
            \checkop(E) => true
        }\mathtt{Eval-check-other}
    \end{align*}
    
    \begin{align*}
        \frac{
            \Gamma \vdash \choke(E) \Rightarrow \Gamma_1 \vdash nil
        }{
            \Gamma \vdash \checkop(E) \Rightarrow \Gamma_1 \vdash nil
        }\mathtt{Choke-check}
    \end{align*}
    
    \subsection{Construction}
    
    \begin{align*}
        \frac{
            \Gamma |- S | E => \Gamma |- S_1 | E_{expr}, E_{vars}
        }{
            \Gamma |- S | ?E => \checkop(E_{expr}), E_{vars}
        }\mathtt{Construct-check}
    \end{align*}
    
    \section{where}
    
    \subsection{Evaluation}
    
    \begin{align*}
        \frac{
            \foreach e_i => v_i..., set(n_i, v_i), E => V
        }{
            \where(E, <n_i, e_i>...) => V
        }\mathtt{Eval-where}
    \end{align*}
    
    \subsection{Construction}
    
    \begin{align*}
    \frac{
            \begin{matrix}
                <nf_i, \Gamma'> = fresh(n_i, \Gamma)... \\
                S' = alloc(nf_i, S)...\\
                E_s = E[n_i/nf_i...] \\
                \Gamma' |- S' | E_s => \Gamma' |- S'_0 | E_{expr}, E_{vars} \\
                es_i = e_i[n_i/nf_i...]... \\
                \Gamma' |- S'_{i-1} | es_i => \Gamma' |- S'_i | e_{i, expr}, e_{i,vars}...
            \end{matrix}
        }{
            \Gamma |- S \left| 
            \begin{array}{l}
                E \where \\
                n_i = e_i; ... \\ 
                end
            \end{array}
            \right. => \Gamma' |- S'_n \left| 
            \begin{matrix}
                \where(E_{expr}, <nf_i, e_{i, expr}>...), \\
                E_{vars} \cup e_{i,vars}... \setminus \{nf_i...\}
            \end{matrix}
            \right.
        }\mathtt{Construct-where}
    \end{align*}
    
    \section{hold}
    
    TODO: how to achieve nested iteration; current theory: specify a set of streams to sample
    from and hold constant while the nested iteration finishes. ?
    
\end{document}